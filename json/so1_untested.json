[{
        "question": "Quale delle seguenti affermazioni sulle directory di un file system \u00e8 vera?",
        "answers": [
            "\u00c8 sempre necessario identificare un file di un file system fornendone il path assoluto",
            "\u00c8 sempre necessario identificare un file di un file system fornendone il path relativo alla directory corrente",
            "\u00c8 sempre possibile dare lo stesso nome a file diversi",
            "Nessuna delle altre opzioni \u00e8 vera"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla concorrenza tra processi o thread \u00e8 falsa?",
        "answers": [
            "La disabilitazione delle interruzioni impedisce la creazione di nuove interruzioni",
            "L'abuso della disabilitazione delle interruzioni fa diminuire la multiprogrammazione, a parit\u00e0 di numero di processi",
            "Se un processo pu\u00f2 disabilitare le interruzioni tramite un'istruzione macchina dedicata, allora pu\u00f2 far diminuire l'uso del processore",
            "La disabilitazione delle interruzioni non funziona su sistemi con pi\u00f9 processori o pi\u00f9 core"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni \u00e8 vera? ",
        "answers": [
            "Lo scheduler ha, tra i suoi obiettivi, quello di minimizzare il numero di processi che rispettano la propria deadline",
            "Lo scheduler ha, tra i suoi obiettivi, quello di minimizzare il volume di lavoro nel tempo",
            "Lo scheduler ha, tra i suoi obiettivi, quello di massimizzare il tempo di risposta",
            "Lo scheduler ha, tra i suoi obiettivi, quello di minimizzare il tempo di inattivit\u00e0 del processore"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul modello dei processi in UNIX SVR4 System V Release 4 \u00e8 falsa?",
        "answers": [
            "Se un processo \u00e8 Zombie, allora \u00e8 terminato ma il suo process control block \u00e8 ancora in memoria",
            "Asleep in Memory coincide con Blocked",
            "Ha anche uno stato Zombie: serve per tutti i processi che sono terminati",
            "Ha 9 stati (10 con Exit)"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla memoria virtuale con paginazione \u00e8 falsa? ",
        "answers": [
            "Quando un indirizzo non viene trovato nel translation lookaside buffer, \u00e8 necessario consultare la normale tabella delle pagine",
            "Il translation lookaside buffer \u00e8 una particolare cache, ma non \u00e8 completamente trasparente al sistema operativo",
            "Il translation lookaside buffer permette di accedere direttamente al contenuto degli indirizzi di memoria virtuali usati pi\u00f9 di recente",
            "In assenza di translation lookaside buffer, l'accesso ad un indirizzo virtuale pu\u00f2 richiedere almeno 2 accessi in memoria"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sugli obiettivi di sicurezza di un sistema operativo \u00e8 vera?",
        "answers": [
            "Per \"disponibilit\u00e0\"dell'hardware si intende la garanzia che le workstation restino sempre fisse in un posto",
            "Per \"confidenzialit\u00e0\"dei dati si intende la garanzia che essi non possano essere generati automaticamente",
            "Nessuna delle altre opzioni \u00e8 vera",
            "Per \"integrit\u00e0\"dei dati si intende la garanzia che essi non vengano mai modificati"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul buffering dell'I\/O \u00e8 vera? ",
        "answers": [
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Avviene direttamente su disco, altrimenti si rischia il deadlock per interferenze con il DMA",
            "Nel caso ci siano pi\u00f9 buffer, vanno gestiti come nel problema dei lettori\/scrittori",
            "Pu\u00f2 consistere nel completare un'istruzione di output I (\u00e8 una i) dopo che alcune istruzioni successive ad I siano state eseguite "
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla gerarchia della memoria \u00e8 vera?",
        "answers": [
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Andando dall'alto in basso, cresce il costo",
            "Andando dall'alto in basso, diminuisce la capacit\u00e0",
            "Andando dall'alto in basso, diminuisce la frequenza di accesso alla memoria da parte del processore"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale dei seguenti elementi non fa parte del process control block?",
        "answers": [
            "Il puntatore alla tabella delle pagine",
            "L\u2019identificatore del thread",
            "Lo stato o modalit\u00e0",
            "L\u2019identificatore del processo"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sugli algoritmi di scheduling \u00e8 vera?",
        "answers": [
            "Nessuna delle altre opzioni \u00e8 vera",
            "Il quanto di tempo ottimale per lo scheduler round-robin \u00e8 maggiore del tipico tempo di completa esecuzione di un processo interattivo",
            "Lo scheduler First Come First Served favorisce i processi I\/O-bound",
            "Anche assumendo che tutti i processi prima o poi terminino, lo scheduler First Come First Served soffre di starvation"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla segmentazione della memoria \u00e8 falsa? ",
        "answers": [
            "Diversi segmenti possono avere diverse lunghezze",
            "Differentemente dalla paginazione, il programmatore assembler di un processo non interagisce esplicitamente con la gestione dei segmenti",
            "Per accedere ad un indirizzo contenuto in un segmento di un processo, tale segmento dovr\u00e0 essere posizionato in memoria principale",
            "Un indirizzo di memoria principale va visto come un numero di segmento pi\u00f9 uno spiazzamento all'interno di tale segmento"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sull'algoritmo per il rilevamento del deadlock visto a lezione \u00e8 vera?",
        "answers": [
            "Richiede in input, per ogni processo p e per ogni risorsa r, il numero massimo di istanze di r che p chieder\u00e0 nel corso della sua esecuzione",
            "Se al passo 3 viene trovato un processo non marcato che soddisfi la condizione Qik \u2264 wik, allora c'\u00e8 un deadlock",
            "I processi marcati sono quelli che non sono coinvolti in un deadlock",
            "Nessuna delle altre opzioni \u00e8 vera"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul long-term scheduler \u00e8 falsa? ",
        "answers": [
            "Viene chiamato in causa esclusivamente quando viene creato un nuovo processo",
            "Avendo le necessarie informazioni, una tipica strategia \u00e8 mantenere una giusta proporzione, stabilita a priori, tra processi I\/O-bound e CPU-bound",
            "Avendo le necessarie informazioni, una tipica strategia \u00e8 ammettere in memoria principale i processi che richiedono dispositivi di I\/O diversi da [...]",
            "Decide quali processi, tra quelli appena creati, possono essere ammessi in memoria principale per l'esecuzione"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla memoria virtuale con paginazione \u00e8 vera? ",
        "answers": [
            "Il difetto principale del prepaging \u00e8 che potrebbe portare in memoria pagine cui poi non si fa riferimento",
            "Placement policy e replacement policy sono sinonimi ed indicano lo stesso insieme di metodologie",
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Il difetto principale del paging on demand \u00e8 che causa molti page fault dopo alcuni secondi di esecuzione"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale dei seguenti requisiti deve soddisfare un meccanismo che offra la mutua esclusione?",
        "answers": [
            "Non deve essere fatta alcuna assunzione sulla velocit\u00e0 di esecuzione dei processi coinvolti",
            "Se un processo fa richiesta di entrare nella sezione critica, deve poterlo fare subito",
            "Se un processo non fa richiesta di entrare nella sezione critica, deve comunque accordarsi all'esecuzione degli altri processi",
            "Si pu\u00f2 assumere che un processo che non sia nella sezione critica prima o poi ci entri"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sui metodi di gestione dello spazio libero su disco \u00e8 vera?",
        "answers": [
            "Se viene usata la lista di blocchi liberi, c'\u00e8 un overhead di spazio, contrariamente alla concatenazione di blocchi liberi",
            "Nessuna delle altre opzioni \u00e8 vera",
            "Se ci sono blocchi da 1kB, e il disco contiene 1TB, l'occupazione dovuta alla lista di blocchi liberi \u00e8 dell'1%",
            "Se viene usata la lista di blocchi liberi, una parte viene memorizzata su disco ed una parte in memoria principale"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul kernel di un sistema operativo \u00e8 vera?",
        "answers": [
            "\u00c8 responsabile dell'accensione del computer ",
            "Viene swappato dal disco alla memoria principale ad ogni context switch ",
            "\u00c8 responsabile, tra le altre cose, della gestione dei processori",
            "Nessuna delle altre opzioni \u00e8 corretta"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sulla preemption \u00e8 vera?",
        "answers": [
            "Se uno scheduler \u00e8 non-preemptive, permette sempre ai suoi processi di essere eseguiti sul processore, senza interruzioni, fino al loro completamento",
            "Se uno scheduler \u00e8 non-preemptive, \u00e8 possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready",
            "Se uno scheduler \u00e8 preemptive, non \u00e8 possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready",
            "Per avere un trattamento equo sui processi, \u00e8 sufficiente usare uno scheduler preemptive"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sugli algoritmi di scheduling \u00e8 vera?",
        "answers": [
            "Con lo scheduler Shortest Process Next, i processi con una grande immagine su RAM potrebbero soffrire di starvation",
            "Lo scheduler round-robin virtuale migliora il round-robin classico, facendo s\u00ec che i processi I\/O-bound non vengano sfavoriti",
            "Lo scheduler First Come First Served \"degenera\"nello scheduler round-robin se il quanto di tempo \u00e8 troppo lungo",
            "Nessuna delle altre opzioni \u00e8 vera"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sugli indirizzi di memoria principale \u00e8 vera?",
        "answers": [
            "Un indirizzo \ufb01sico fa sempre riferimento alla memoria secondaria",
            "Per rispettare il requisito di rilocazione, occorre trasformare indirizzi \ufb01sici in logici",
            "Gli indirizzi relativi sono usati nella paginazione",
            "Nessuna delle altre opzioni \u00e8 corretta"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sui termini tipici della concorrenza \u00e8 falsa?",
        "answers": [
            "Una sezione critica \u00e8 una porzione di memoria che contiene almeno una variabile condivisa tra pi\u00f9 processi",
            "Una operazione atomica \u00e8 una sequenza di istruzioni macchina tale che, se un processo la esegue, allora arriver\u00e0 a termine senza interruzioni da altri processi",
            "Il requisito di mutua esclusione prevede che un solo processo possa eseguire un certo segmento di codice o accedere ad una determinata risorsa",
            "Una race condition \u00e8 una violazione della mutua esclusione || \u00c8 possibile che 2 distinti processi chiamino la stessa funzione atomica"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale dei seguenti elementi fa parte del process control block?",
        "answers": [
            "Nessuna delle altre opzioni contiene elementi del process control block",
            "Le informazioni sul contesto del processo, aggiornate ad ogni istruzione eseguita",
            "L'intera immagine del processo in memoria",
            "La tabella delle pagine di secondo livello"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti informazioni non \u00e8 presente in una tipica entry di una directory di un \ufb01le system?",
        "answers": [
            "Il gruppo cui appartiene l'utente che ha creato il \ufb01le",
            "La data di creazione del \ufb01le",
            "Autorizzazioni per l'accesso al \ufb01le",
            "Dimensione del \ufb01le"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sugli algoritmi di scheduling per i dischi \u00e8 vera?",
        "answers": [
            "Nessuna delle altre opzioni \u00e8 corretta",
            "L'algoritmo C-SCAN deriva da SCAN, ed \u00e8 stato sviluppato per evitare di favorire le richieste di tracce ai bordi del disco",
            "Per valutare le prestazioni dell'algoritmo con priorit\u00e0 \u00e8 sufficiente fornire il ruolo degli utenti dei processi che effettuano le richieste",
            "L'algoritmo random ha la stessa funzione dell'algoritmo ottimo dei rimpiazzamenti di pagina: ha delle prestazioni ottime non raggiungibili dagli altri algoritmi"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul metodo di allocazione contigua dei file \u00e8 vera? ",
        "answers": [
            "\u00c8 possibile che ci sia frammentazione interna",
            "La compattazione permette di memorizzare file che altrimenti non potrebbero esserlo (pur essendo la loro dimensione minore di quella dello spazio libero)",
            "Non \u00e8 necessaria la preallocazione",
            "La tabella di allocazione dei file necessita di memorizzare, per ogni file, il solo blocco di partenza"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla paginazione della memoria \u00e8 vera? ",
        "answers": [
            "Frame e pagine devono avere la stessa dimensione",
            "Tutte le pagine di un processo dovranno essere, prima o poi, posizionate in un frame",
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Soffre del problema della frammentazione interna, e quindi necessita compattazione"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul controllo di accesso \u00e8 vera? ",
        "answers": [
            "Nel controllo di accesso basato su ruoli, ad ogni ruolo \u00e8 assegnato un utente",
            "Nel controllo di accesso basato su ruoli, prima di stabilire se un'operazione \u00e8 lecita, \u00e8 necessario consultare una tabella soggetti-ruoli-oggetti",
            "Nel controllo di accesso discrezionale, prima di stabilire se un'operazione \u00e8 lecita, \u00e8 necessario consultare una tabella soggetti-oggetti",
            "Nessuna delle altre opzioni \u00e8 vera"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni \u00e8 falsa? ",
        "answers": [
            "Nel caso delle risorse riusabili, in un grafo dell'allocazione delle risorse ci possono essere pi\u00f9 archi tra lo stesso nodo-processo e lo stesso nodo-risorsa",
            "Nel caso delle risorse riusabili, in un grafo dell'allocazione delle risorse ci possono essere archi sia da nodi-processi a nodi-risorse che viceversa",
            "Un grafo dell'allocazione delle risorse \u00e8 un grafo diretto aciclico",
            "In un grafo dell'allocazione delle risorse, all'interno di un nodo rappresentante una risorsa, c'\u00e8 un pallino per ogni istanza di quella risorsa"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quali delle seguenti affermazioni \u00e8 vera? ",
        "answers": [
            "La confidenzialit\u00e0 di un sistema operativo consiste nel fatto che la shell del sistema operativo deve essere intuitiva e dare del tu agli utenti",
            "La disponibilit\u00e0 (availability) di un sistema operativo consiste nel fatto che il sistema operativo deve essere sempre pronto a rispondere alle richieste di un utente",
            "La disponibilit\u00e0 (availability) di un sistema operativo consiste nel fatto che devono esistere delle repository online che permettano sia di installare che di aggiornare il sistema operativo",
            "La confidenzialit\u00e0 di un sistema operativo consiste nel fatto che il sistema operativo deve essere sempre pronto a rispondere alle richieste di un utente"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla memoria virtuale con paginazione \u00e8 vera? ",
        "answers": [
            "Il difetto principale del prepaging \u00e8 che potrebbe portare in memoria pagine cui poi non si fa riferimento",
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Il difetto principale del paging on demand \u00e8 che, dopo una prima fase di assestamento, causa molti page fault",
            "Placement policy e replacement policy sono sinonimi ed indicano lo stesso insieme di metodologie"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sui dispositivi di memoria di massa \u00e8 vera? ",
        "answers": [
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Un settore di un disco magnetico a testina mobile \u00e8 l'area di una corona circolare del disco stesso",
            "Una traccia di un disco magnetico a testina mobile \u00e8 l'area compresa da 2 raggi del disco stesso",
            "Per selezionare un settore su una traccia di un disco magnetico a testina mobile, \u00e8 sufficiente posizionare la testina sulla giusta traccia"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul process control block \u00e8 vera? ",
        "answers": [
            "Viene salvato nella memoria utente assegnata al processo cui si riferisce",
            "Contiene tutte le informazioni sui thread del processo cui si riferisce",
            "Per i processi in modalit\u00e0 blocked, tutte le informazioni che contiene sono cancellate",
            "Nessuna delle altre opzioni \u00e8 vera"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sui semafori per la gestione della concorrenza \u00e8 falsa? ",
        "answers": [
            "Semafori generali e semafori binari hanno lo stesso potere computazionale (ovvero, permettono di risolvere gli stessi problemi)",
            "Le primitive sui semafori sono in grado di mettere un processo in blocked, senza usare, a tal proposito, il busy-waiting",
            "Per implementare le primitive sui semafori, servono un contatore ed una coda, che saranno condivisi da tutti i semafori usati",
            "L'implementazione delle primitive sui semafori \u00e8 garantita atomica dal sistema operativo"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sugli algoritmi di scheduling per i dischi \u00e8 falsa? ",
        "answers": [
            "Nell'algoritmo F-SCAN, immediatamente prima che vengano scambiati i contenuti delle code F ed R, la coda F \u00e8 vuota, mentre la coda R contiene le richieste arrivate mentre si servivano le richieste dentro F",
            "L'algoritmo Minimum Service Time pu\u00f2 portare alla starvation di un processo, che non verr\u00e0 quindi mai selezionato, se la richiesta era bloccante, per andare in esecuzione sul processore",
            "L'algoritmo LIFO \u00e8 il pi\u00f9 equo nei confronti dei processi che effettuano le richieste al disco",
            "Gli algoritmi Minimum Service Time, SCAN, C-SCAN, N-steps-SCAN ed F-SCAN non sono ottimizzati per essere usati su dischi con testine multiple selezionabili elettronicamente"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul long-term scheduler \u00e8 falsa? ",
        "answers": [
            "Decide quali processi, tra quelli appena creati, possono essere ammessi in memoria principale per l'esecuzione",
            "Avendo le necessarie informazioni, una tipica strategia \u00e8 mantenere una giusta proporzione, stabilita a priori, tra processi I\/O-bound e CPU-bound",
            "Viene chiamato in causa esclusivamente quando viene creato un nuovo processo",
            "Avendo le necessarie informazioni, una tipica strategia \u00e8 ammettere in memoria principale i processi che richiedono dispositivi di I\/O diversi da quelli richiesti dai processi gi\u00e0 attivi"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sui metodi di gestione dello spazio libero su disco \u00e8 vera? ",
        "answers": [
            "Se ci sono blocchi da 1kB, e il disco contiene 1TB, l'occupazione dovuta alla lista di blocchi liberi \u00e8 dell'1%",
            "Se viene usata la lista di blocchi liberi, tale lista viene interamente mantenuta in memoria principale",
            "Nessuna delle altre opzioni \u00e8 vera",
            "Se viene usata la lista di blocchi liberi, c'\u00e8 un overhead di spazio, contrariamente alla concatenazione di blocchi liberi"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    
{
        "question": "Quale delle seguenti affermazioni sulla memoria cache \u00e8 vera? ",
        "answers": [
            "La memoria cache \u00e8 direttamente indirizzabile in assembler",
            "Nessuna delle altre opzioni \u00e8 corretta",
            "\u00c8 possibile che, in un dato istante, la cache e la memoria RAM non siano coerenti tra loro",
            "L'algoritmo di rimpiazzamento per la cache stabilisce quale blocco di RAM deve essere sostituito da un blocco di cache"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sui problemi dei produttori\/consumatori e dei lettori\/scrittori, nelle accezioni viste a lezione, \u00e8 vera? ",
        "answers": [
            "Per il problema dei produttori\/consumatori, non deve essere mai possibile che pi\u00f9 consumatori accedano contemporaneamente al buffer, mentre nel problema dei lettori\/scrittori deve sempre possibile che pi\u00f9 lettori, in assenza di scrittori, accedano all'area di memoria",
            "Per il problema dei produttori\/consumatori, non deve essere mai possibile che pi\u00f9 produttori accedano contemporaneamente al buffer, mentre nel problema dei lettori\/scrittori deve essere sempre possibile che pi\u00f9 scrittori (in assenza di lettori) accedano all'area di memoria",
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Per il problema dei produttori\/consumatori, deve essere sempre possibile che pi\u00f9 consumatori accedano contemporaneamente al buffer, mentre nel problema dei lettori\/scrittori non deve essere mai possibile che pi\u00f9 scrittori accedano all'area di memoria"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sui (vecchi) metodi per il partizionamento della memoria \u00e8 vera? ",
        "answers": [
            "Con il partizionamento fisso, le partizioni devono avere tutte la stessa dimensione",
            "Con il buddy system, ogni indirizzo di memoria pu\u00f2 ricadere in 2 porzioni",
            "Con il partizionamento fisso, ci possono essere al massimo N processi attivi (ovvero, accettati per l'esecuzione), dove N \u00e8 il numero di partizioni",
            "Con il partizionamento dinamico, si manifesta il problema della frammentazione esterna"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sulla preemption \u00e8 vera? ",
        "answers": [
            "Se uno scheduler \u00e8 preemptive e vi \u00e8 pi\u00f9 di 1 processo ready, non \u00e8 possibile che un processo monopolizzi il processore",
            "Per avere un trattamento equo sui processi, \u00e8 sufficiente usare uno scheduler preemptive",
            "Se uno scheduler \u00e8 non-preemptive, permette sempre ai suoi processi di essere eseguiti senza interruzioni sul processore fino al loro completamento",
            "Se uno scheduler \u00e8 non-preemptive, \u00e8 possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Nel modello dei processi a 5 stati, quali delle seguenti transizioni non \u00e8 possibile? ",
        "answers": [
            "Blocked == Running",
            "Running == Ready",
            "Blocked == Exit",
            "Blocked == Ready"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul metodo di allocazione indicizzata dei file \u00e8 vera? ",
        "answers": [
            "Il consolidamento permette sempre di ridurre la dimensione dell'indice",
            "Se usato con porzioni di dimensione variabile, i blocchi indice devono contenere anche la lunghezza di ogni porzione",
            "Nessuna delle altre opzioni \u00e8 vera",
            "Non c'\u00e8 modo per il sistema operativo di distinguere tra blocchi con dati e blocchi con indici"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul requisito di rilocazione nella gestione della memoria \u00e8 vera? ",
        "answers": [
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Se viene realizzato tramite sostituzione degli indirizzi nel programma sorgente (al momento della creazione del processo), allora il relativo processo dovr\u00e0 cominciare sempre allo stesso indirizzo; tale indirizzo dovr\u00e0 essere uguale per tutti i processi",
            "Se viene realizzato tramite sostituzione degli indirizzi nel programma sorgente (al momento della creazione del processo), allora il relativo processo potr\u00e0 trovarsi in diverse posizioni della memoria in diversi momenti del sua esecuzione",
            "Se viene realizzato tramite sostituzione degli indirizzi nel programma sorgente (al momento della creazione del processo), serve hardware speciale"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sulla preemption \u00e8 vera?",
        "answers": [
            "Se uno scheduler \u00e8 non-preemptive, permette sempre ai suoi processi di essere eseguiti sul processore, senza interruzioni, fino al loro completamento",
            "Se uno scheduler \u00e8 non-preemptive, \u00e8 possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready",
            "Se uno scheduler \u00e8 preemptive, non \u00e8 possibile che un processo monopolizzi il processore, anche in presenza di altri processi ready",
            "Per avere un trattamento equo sui processi, \u00e8 sufficiente usare uno scheduler preemptive"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale dei seguenti requisiti deve soddisfare un meccanismo che offra la mutua esclusione? ",
        "answers": [
            "Non deve essere fatta alcuna assunzione sulla velocit\u00e0 di esecuzione dei processi coinvolti",
            "Se un processo non fa richiesta di entrare nella sezione critica, deve comunque sincronizzarsi all'esecuzione degli altri processi",
            "Se un processo \u00e8 nella sezione critica, occorre che rilasci subito la sezione critica stessa",
            "Se un processo fa richiesta di entrare nella sezione critica, deve poter entrare subito nella sezione critica stessa"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul dispatcher \u00e8 falsa? ",
        "answers": [
            "Il resource balancing \u00e8 un criterio di sistema non prestazionale",
            "Il rispetto delle deadline \u00e8 un criterio utente prestazionale",
            "Il throughput \u00e8 un criterio di sistema prestazionale",
            "La predictability \u00e8 un criterio utente prestazionale"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sugli interrupt (o eccezioni) \u00e8 falsa? ",
        "answers": [
            "Devono essere gestiti da opportuno software di sistema",
            "Una volta gestito l'interrupt o l'eccezione, quando (e se) si torna ad eseguire il processo interrotto, l'esecuzione ripartir\u00e0 sempre dall'istruzione successiva a quella dove \u00e8 stato ricevuto l'interrupt o l'eccezione",
            "Normalmente, non vengono gestiti dal programmatore dell'applicazione che li ha causati",
            "Possono essere creati direttamente dai dispositivi di I\/O"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulle istruzioni macchina speciali per la gestione della concorrenza \u00e8 vera? ",
        "answers": [
            "Sono basate sul busy-waiting, ovvero sul fatto che un processo si mette autonomamente in stato blocked",
            "Nessuna delle altre opzioni \u00e8 vera",
            "Non riescono ad evitare il manifestarsi del deadlock, a meno che non sia presente un sistema a priorit\u00e0",
            "Come per la disabilitazione delle interruzioni, non funzionano per architetture con pi\u00f9 processori o core"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sui processi \u00e8 vera? ",
        "answers": [
            "Nessuna delle altre opzioni \u00e8 vera",
            "Per la terminazione normale di un processo, \u00e8 tipicamente prevista un'apposita system call, come ad esempio exit",
            "Un processo pu\u00f2 morire quando si effettua il process spawning",
            "Un processo pu\u00f2 essere creato dal modulo di gestione della memoria per gestire la traduzione da indirizzi virtuali a fisici"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni \u00e8 falsa? ",
        "answers": [
            "Nel caso di un sistema operativo a kernel separato, la gestione dei process switch \u00e8 a sua volta un processo",
            "Nel caso di un sistema operativo in cui le funzioni del sistema operativo vengono eseguite all'interno dei processi utente, non c'\u00e8 bisogno di un process switch per eseguire una funzionalit\u00e0 del sistema operativo",
            "Nel caso di un sistema operativo in cui le funzioni del sistema operativo vengono eseguite all'interno dei processi utente, se un processo effettua una syscall e poi pu\u00f2 continuare ad essere eseguito, non avviene alcun process switch",
            "Nel caso di un sistema operativo in cui le funzioni del sistema operativo vengono eseguite come processi separati, c'\u00e8 sempre bisogno di un process switch per eseguire una funzionalit\u00e0 del sistema operativo"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul metodo di allocazione concatenata dei file \u00e8 vera? ",
        "answers": [
            "Il consolidamento permette di memorizzare file che altrimenti non potrebbero esserlo (pur essendo la loro dimensione minore di quella dello spazio libero)",
            "La tabella di allocazione dei file deve contenere l'intera catena",
            "Nessuna delle altre opzioni \u00e8 vera",
            "Viene usato con porzioni di dimensione variabile, ma piccola"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla memoria virtuale con paginazione \u00e8 vera? ",
        "answers": [
            "Nel caso di una tabella delle pagine a 2 livelli, viene tipicamente richiesto che tutte le tabelle delle pagine di secondo livello entrino in una pagina",
            "Il numero di bit di un indirizzo virtuale \u00e8 necessariamente diverso a seconda che si usi una tabella delle pagine ad 1 o a 2 livelli",
            "Il numero di bit di una entry di una tabella delle pagine di ultimo livello \u00e8 uguale al numero di bit di controllo pi\u00f9 il logaritmo (arrotondato all'intero superiore) del massimo numero di frame in memoria principale",
            "Nessuna delle altre opzioni \u00e8 corretta"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sul deadlock \u00e8 falsa? ",
        "answers": [
            "Affinch\u00e8 ci sia un deadlock, sono necessarie le condizioni di attesa circolare, hold-and-wait, mutua esclusione e no preemption",
            "Per prevenire il deadlock, \u00e8 necessario cercare di impedire almeno una delle 3 condizioni di mutua esclusione, hold-and-wait e no preemption",
            "Affinch\u00e8 il deadlock sia possibile, sono necessarie le condizioni di mutua esclusione, hold-and-wait e no preemption",
            "Per prevenire il deadlock impedendo l'hold-and-wait, si pu\u00f2 in alcuni casi imporre ai processi di richiedere tutte le risorse fin dall'inizio"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni \u00e8 vera? ",
        "answers": [
            "La modalit\u00e0 di un processo utente \u00e8 sempre la modalit\u00e0 di sistema",
            "La modalit\u00e0 di un processo utente \u00e8 inizialmente la modalit\u00e0 utente; pu\u00f2 diventare modalit\u00e0 sistema nel momento in cui va in esecuzione il dispatcher",
            "Nessuna delle altre opzioni \u00e8 vera",
            "La modalit\u00e0 di un processo utente \u00e8 sempre la modalit\u00e0 utente"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla memoria virtuale con paginazione \u00e8 vera? ",
        "answers": [
            "Nessuna delle altre opzioni \u00e8 corretta",
            "Per ogni processo, il resident set contiene lo stesso numero di pagine",
            "Un tipico algoritmo per il replacement scope \u00e8 quello dell'orologio",
            "La gestione del resident set tramite politica dinamica mira ad ampliare il numero di pagine di un processo durante l'esecuzione del processo stesso"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sul dispatcher \u00e8 falsa?",
        "answers": [
            "Il response time \u00e8 un criterio utente prestazionale",
            "Il turnaround time (normalizzato o no) \u00e8 un criterio utente prestazionale",
            "Il throughput \u00e8 un criterio di sistema non prestazionale",
            "La fairness \u00e8 un criterio di sistema non prestazionale"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni \u00e8 falsa?",
        "answers": [
            "Diversi thread di uno stesso processo condividono lo stesso thread identifier",
            "Tra le funzioni di sistema per i thread, \u00e8 tipicamente prevista una funzione per bloccare e sbloccare esplicitamente i thread stessi",
            "Diversi thread di uno stesso processo condividono lo stesso process identifier",
            "Diversi thread di uno stesso processo condividono i file aperti"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quale delle seguenti affermazioni sulla page cache \u00e8 falsa?",
        "answers": [
            "Nell'algoritmo di sostituzione basato su frequenza a 3 segmenti della page cache, i contatori vengono sempre incrementati, tranne quando sono nel segmento vecchio",
            "Nell'algoritmo di sostituzione basato su frequenza a 3 segmenti della page cache, i settori che possono essere sostituiti sono solo quelli del segmento vecchio",
            "Nell'algoritmo di sostituzione basato su frequenza a 3 segmenti della page cache, l'unico segmento in cui i contatori non vengono incrementati e i settori non possono essere sostituti \u00e8 quello nuovo",
            "L'algoritmo di sostituzione basato su frequenza a 3 segmenti della page cache pu\u00f2 avere buone performance anche quando dei settori vengono acceduti spesso, ma tra il primo accesso e quelli successivi ci sono molti altri accessi ad altri settori"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Quali delle seguenti affermazioni sulla efficienza di un sistema operativo \u00e8 falsa?",
        "answers": [
            "Deve minimizzare il tempo di risposta, tenendo presenti eventuali priorit\u00e0",
            "Deve servire il maggior numero di utenti possibile, tenendo presenti eventuali livelli di accesso",
            "Deve dare accesso alle risorse in modo equo ed egualitario tra tutti i processi",
            "Deve massimizzare l'uso delle risorse per unit\u00e0 di tempo, tenendo presenti eventuali priorit\u00e0"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Si consideri una unit\u00e0 disco con una velocit\u00e0 di rotazione di R rivoluzioni al minuto (rpm). La testina, per spostarsi da una traccia alla successiva, impiega un tempo trascurabile. Ogni traccia del disco contiene T kB. Si assuma che una porzione di dimensione P kB di un file sia memorizzata sul disco in settori contigui. Stimare il tempo totale, in secondi, necessario per il trasferimento di questi P kB di dati dal disco in memoria principale, nel caso in cui la testina sia gi\u00e0 posizionata sul settore di partenza.",
        "answers": [
            "P\/(T*R\/60)",
            "T*(R\/60)\/P",
            "T\/(P*R\/60)",
            "P*R\/60"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Un sistema con gestione paginata semplice della memoria ha indirizzi di B bit e pagine di dimensione P kB. Se tutta la memoria \u00e8 paginabile, qual \u00e8 il numero massimo di elementi contenuti nella tabella delle pagine di un processo?",
        "answers": [
            "P\/B",
            "P*1024\/2B",
            "2^B\/(P*1024)",
            "B\/P"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""
    },
    {
        "question": "Si consideri la seguente soluzione (sbagliata) al problema della mutua esclusione tra processi: ",
        "answers": [
            "Assumendo che il dispatcher, prima o poi, dia l'opportunità di andare in esecuzione a tutti i processi coinvolti, è comunque possibile la starvation (rispetto all'entrata nella sezione critica)",
            "Nessuna delle altre opzioni è vera",
            "Supponendo che ci siano 2 processi, se lo scheduler permette a P(0) di arrivare fino ad assegnare 1 a bolt, allora il requisito base della mutua esclusione (sul numero massimo di processi nella sezione critica) è rispettato",
            "Sono possibili deadlock"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "int bolt = 0;\r\nvoid P(int i)\r\n    while (bolt == 1) \/* do nothing *\/;\r\n    bolt = 1;\r\n    \/* critical section *\/;\r\n    bolt = 0;\r\n    \/* remainder *\/;"
    },
    {

        "question": "Si consideri il seguente modo di implementare la mutua esclusione:",
        "answers": [
            "La soluzione implementa correttamente la mutua esclusione solo se si disabilitano le interruzioni prima di chiamare P",
            "Nessuna delle altre opzioni è vera",
            "La soluzione non implementa correttamente la mutua esclusione perché bisogna chiamare exchange invece di compare_and_swap",
            "La soluzione non implementa correttamente la mutua esclusione"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "int bolt = 1;\r\nvoid P(int i)\r\n    while(true)\r\n      while (compare_and_swap(bolt, 1, 0) == 0) ;\r\n      critical_section();\r\n      bolt = 1;"
    },
    {

        "question": "Si consideri la seguente soluzione al problema della mutua esclusione tra processi: ",
        "answers": [
            "Il requisito base della mutua esclusione (sul numero massimo di processi nella sezione critica) è rispettato",
            "È certo il deadlock",
            "Se si scambiano le chiamate semWait e semSignal, il requisito base della mutua esclusione (sul numero massimo di processi in sezione critica) non è rispettato",
            "Se si elimina la chiamata a semWait, il requisito base della mutua esclusione (sul numero massimo di processi nella sezione critica) è rispettato"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "semaphore s = 0;\r\nvoid P(int i)\r\n    semWait(s);\r\n    \/* critical section *\/;\r\n    semSignal(s);\r\n    \/* remainder *\/;"
    },
    {

        "question": "I seguenti due processi concorrenti condividono una variabile: ",
        "answers": [
            "N*2 + 1, 2*(N + 1), N + 1",
            "N*2 + 1, 2*(N + 1), N*2",
            "N*2 + 1, 2*(N + 1)",
            "N*2 + 1, 2*(N + 1), N + 1, N*2"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "semaphore S = 1;\r\nint X = N;\r\n\r\n[Process 1]             [Process 2]\r\n    int Y;                       int Z;\r\n    semWait(S);          semWait(S);    \r\n    Y = X*2;                  Z = X+1;\r\n    X = Y;                      X = Z;\r\n    semSignal(S);       semSignal(S); "
    },
    {

        "question": "I seguenti tre processi concorrenti condividono due semafori: ",
        "answers": [
            "0",
            "3",
            "Infinito",
            "Nessuna delle altre opzioni è corretta"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "semaphore U = 3; \r\nsemaphore V = 0;\r\n\r\n[Process 1]                      [Process 2]                        [Process 3]\r\n  while(1)                           while(1)                              while(1)  \r\n        semWait(U);                     semWait(V);                       semWait(V);\r\n        print(\"A\");                          print(\"B\");                             print(\"C\");\r\n        semSignal(V);                  semSignal(V);\r\n"
    },
    {

        "question": "Si consideri la seguente soluzione al problema della mutua esclusione tra processi: ",
        "answers": [
            "Se n = 1, non c'è deadlock ",
            "Se n > 1, non c'è deadlock ",
            "Il requisito base della mutua esclusione (sul numero massimo di processi nella sezione critica) è rispettato ",
            "Almeno un requisito della mutua esclusione non è rispettato "
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "const message null = \/* null message *\/; \r\nmailbox box;\r\nvoid P(int i) { \r\n     message msg;\r\n     while (true) {\r\n          receive(box, msg);\r\n          \/* critical section *\/;  \r\n          send(box, msg);\r\n          \/* remainder *\/;  } }\r\n\r\nvoid main() {\r\n     box = create_mailbox();\r\n     nbsend(box, null);\r\n     parbegin (P(1), P(2), . . ., P(n));  }"
    },
    {

        "question": "Si consideri la soluzione al problema del produttore/consumatore che usa lo scambio messaggi vista a lezione. Quale delle seguenti affermazioni è vera?",
        "answers": [
            "Assumendo che non ci siano errori in precedenza, è possibile che 2 produttori tentino di immettere contemporaneamente 2 diversi prodotti nello stesso slot del buffer",
            "Assumendo che non ci siano errori in precedenza, è possibile che un consumatore tenti di prelevare un prodotto dal buffer quando quest'ultimo è vuoto",
            "Assumendo che non ci siano errori in precedenza, è possibile che un produttore tenti di immettere un prodotto nel buffer quando quest'ultimo è pieno",
            "Nessuna delle altre opzioni è corretta"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "const int capacity = \/* buffering capacity *\/ ;\r\n           mailbox mayproduce, mayconsume;\r\n    \r\n     void main() {\r\n         mayproduce = create_mailbox(),\r\n         mayconsume = create_mailbox();\r\n         for (int i = 1; i <= capacity; i++)\r\n              nbsend (mayproduce,null);\r\n         parbegin (producer,consumer); }\r\n    \r\n    void producer() {\r\n         message pmsg;\r\n         while (true) {\r\n           receive (mayproduce,pmsg);\r\n           pmsg = produce(); \/* fa anche append *\/\r\n           nbsend (mayconsume,pmsg);  } }\r\n    \r\n    void consumer() {\r\n         message cmsg;\r\n         while (true) {\r\n           receive (mayconsume,cmsg);\r\n           consume (cmsg); \/* fa anche take *\/\r\n           nbsend (mayproduce,null);  } }"
    },
    {

        "question": "Considerare un insieme di cinque processi P1, P2, P3, P4, P5 con i seguenti tempi di arrivo e tempi di esecuzione in millisecondi. Quale delle seguenti affermazioni è falsa?",
        "answers": [
            "Non ci sono sufficienti informazioni per determinare come si comporterebbe l'algoritmo di scheduling a feedback classico di Unix",
            "Non ci sono sufficienti informazioni per determinare come si comporterebbe l'algoritmo di scheduling Virtual Round-Robin",
            "Non ci sono sufficienti informazioni per determinare come si comporterebbe l'algoritmo di scheduling Round-Robin",
            "Non ci sono sufficienti informazioni per determinare come si comporterebbe l'algoritmo di scheduling SRT"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "Processo    Tempo di Arrivo Tempo di Esecuzione\r\nP1  0   14\r\nP2  8   16\r\nP3  5   3\r\nP4  11  7\r\nP5  17  9\r\n"
    },
    {

        "question": "Considerare un insieme di cinque processi P1, P2, P3, P4, P5 con i seguenti tempi di arrivo e tempi di esecuzione in millisecondi. Quale delle seguenti affermazioni è falsa?",
        "answers": [
            "Gli unici 2 processi che non sono serviti subito (ovvero, appena arrivati) sono P3 e P5",
            "Il tempo medio di attesa è tra 10 ed 11 ms",
            "Il processo con il più lungo tempo di attesa è P1",
            "Il tempo medio di turnaround è tra 2 e 3 ms "
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 1,
        "code": "Processo    Tempo di Arrivo Tempo di Esecuzione\r\nP1  0   14\r\nP2  8   16\r\nP3  5   3\r\nP4  11  7\r\nP5  17  9\r\n"
    },
    {

        "question": "Quale delle seguenti affermazioni, riguardanti il joint progress diagram di 2 processi, è vera? ",
        "answers": [
            "Nessuna delle altre opzioni è vera",
            "Può essere usato per visualizzare le possibilità di deadlock, ma solo se i processi richiedono al massimo 2 risorse",
            "Può essere usato per determinare quando uno dei due processi va in esecuzione a discapito dell'altro",
            "Può essere usato per determinare quando uno dei due processi sperimenta un page fault"    
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {

        "question": "Quale delle seguenti affermazioni sui dispositivi di I/O è vera? ",
        "answers": [
            "Il data rate confronta le velocità di trasferimento dati tra 2 diversi dispositivi di I/O",
            "Ciascun dispositivo di I/O può essere usato solo da un ben determinato tipo di applicazioni",
            "Nessuna delle altre opzioni è corretta",
            "Tutti i dispositivi di I/O scambiano informazioni con la CPU in blocchi, per motivi di efficienza"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {

        "question": "Quale delle seguenti affermazioni sulla traduzione di un indirizzo virtuale in fisico, in un sistema con memoria virtuale con paginazione (avente tabella delle pagine ad 1 livello), è falsa?",
        "answers": [
            "L'hardware deve anche estrarre dall'indirizzo virtuale il numero di pagina virtuale; tale operazione è equivalente ad una divisione intera",
            "L'hardware deve anche usare il numero di pagina per accedere alla tabella delle pagine del processo in esecuzione. A tal proposito, deve conoscere l'inizio di tale tabella, che viene definito dal software (sistema operativo). Tale indirizzo può cambiare durante l'esecuzione del processo: sta al sistema operativo mantenerlo aggiornato",
            "L'hardware deve anche usare il numero di frame ottenuto dalla tabella delle pagine per comporre, insieme con l'offset originale, l'indirizzo fisico. Tale operazione è equivalente ad uno shift seguito da una somma",
            "L'hardware deve anche cercare il numero di pagina nelle entries della tabella delle pagine del processo in esecuzione."
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Quale delle seguenti affermazioni sui file system è vera? ",
        "answers": [
            "I file system, che adottano il metodo journaling, mantengono un log per le operazioni di sola scrittura da effettuare, e le realizzano solo in un secondo momento",
            "Un volume coincide sempre con un disco, quindi se un computer ha 2 dischi avrà 2 volumi",
            "I dati possono essere ricavati dai metadati",
            "I metadati possono essere ricavati dai dati"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Quale delle seguenti affermazioni sui meccanismi per la gestione della concorrenza è vera? ",
        "answers": [
            "Usando i semafori di qualsiasi tipo, è possibile scrivere processi che non soffrano di starvation",
            "Disabilitando gli interrupt, è possibile scrivere processi che non soffrano di starvation",
            "Senza usare né semafori, né scambio messaggi, né istruzioni macchina atomiche, è possibile scrivere processi che non soffrano di starvation per garantire la mutua esclusione tra 2 processi",
            "Usando le istruzioni macchina exchange e compare_and_swap, è possibile scrivere processi che non soffrano di starvation"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Quale dei seguenti elementi non è una delle parti che definiscono un processo? ",
        "answers": [
            "Informazioni sullo stato delle risorse",
            "La priorità",
            "Il contatore di programma",
            "I dati contenuti nella porzione di memoria a lui dedicata"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Un computer esegue 20 istruzioni ogni microsecondo. Ricordando che 1 millisecondo = 1000 microsecondi = 1000000 nanosecondi, per eseguire una singola istruzione impiega",
        "answers": [
            "0.05 microsecondi",
            "0.05 millisecondi",
            "0.05 nanosecondi",
            "Nessuna delle altre opzioni è corretta"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Quale delle seguenti affermazioni è falsa?",
        "answers": [
            "Diversi thread di uno stesso processo condividono lo stesso thread identifier[1]",
            "Tra le funzioni di sistema per i thread, è tipicamente prevista una funzione per bloccare e sbloccare esplicitamente i thread stessi",
            "Diversi thread di uno stesso processo condividono lo stesso process identifier",
            "Diversi thread di uno stesso processo condividono i file aperti"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Quale delle seguenti affermazioni è vera?",
        "answers": [
            "Nessuna delle altre opzioni è corretta",
            "Nell'algoritmo di sostituzione basato su frequenza a 2 segmenti della page cache, un blocco passa da un segmento ad un altro esclusivamente per scorrimento",
            "L'algoritmo di LFU della page cache ha buone performance quando un settore viene acceduto molto spesso in poco tempo, per poi non essere più usato",
            "L'algoritmo di sostituzione basato su frequenza a 2 segmenti della page cache può non avere buone performance quando un settore viene acceduto spesso, ma tra il primo accesso..."
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Quale delle seguenti affermazioni sugli i-node di UNIX è falsa?",
        "answers": [
            "Ogni directory può contenere molti i-node",
            "Per modificare una directory un utente deve aprire il file speciale corrispondente e poi modifcarlo opportunamente",
            "ogni directory è un file speciale, organizzato come una lista di entry, ciascuna delle quali contiene il nome del file ed il relativo i-node number",
            "Ogni directory è identificata da un i-node"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Quale delle seguenti affermazioni è vera sulla memoria virtuale con paginazione a segmentazione?",
        "answers": [
            "Sia la tabella dei segmenti che quella delle pagine di un processo contengono, in ciascuna entry, un bit per indicare se la pagina o il segmento sono stati modificati",
            "Un indirizzo virtuale contiene anche un bit per indicare se la pagina corrispondente è o no in memoria principale",
            "La tabella delle pagine di un processo contiene una pagina speciale dove è memorizzato il process control block del processo stesso",
            "Ogni entry di una tabella delle pagine contiene un numero di pagina ed un offset"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },

    {
        "question": "Quale delle seguenti affermazioni sulla memoria virtuale con paginazione è vera?",
        "answers": [
            "Per avere un overhead accettabile, occorre demandare la traduzione degli indirizzi all'hardware, mentre al software resta da gestire prelievo, posizionamento e sostituzione delle pagine",
            "Per avere un overhead accettabile, occorre demandare la traduzione degli indirizzi e la politica di sostituzione delle pagine all'hardware, mentre al software resta da gestire prelievo e posizionamento delle pagine",
            "Per avere un overhead accettabile, occorre demandare all'hardware la traduzione degli indirizzi ed il prelievo, il posizionamento e la sostituzione delle pagine",
            "Per avere un overhead accettabile, occorre demandare al software anche la traduzione degli indirizzi"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Quale delle seguenti affermazioni sulla concorrenza tra processi o thread è vera?",
        "answers": [
           "L'istruzione exchange non può ricevere costanti in input su nessun suo argomento, mentre per l'istruzione compare_and_swap questo non vale",
           "Per realizzare opportunamente l'istruzione compare_and_swap è sufficiente disabilitare le interruzioni",
           "Le istruzioni speciali exchange e compare_and_swap sono garantite atomiche dal sistema operativo",
           "Nessuna delle altre opzioni è vera"
        ],
        "correct": "b",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question": "Assumendo un sistema monoprocessore, quale delle seguenti affermazioni sugli algoritmi di scheduling è vera?",
        "answers": [
            "L'exponential averaging permette di stimare la dimensione dell'immagine di un processo, a partire dalle precedenti immagini di quello stesso processo",
            "La funzione di decisione dello scheduler Highest Response Ratio Next considera tanto il tempo di esecuzione stimato quanto il tempo trascorso in attesa",
            "L'exponential averaging è una tecnica applicabile dal solo scheduler Short Process Next",
            "La funzione di decisione dello scheduler Shortest Remaining Time considera tanto il tempo di esecuzione richiesto quanto il tempo trascorso in attesa"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question":"Quale delle seguenti azioni non viene necessariamente eseguita al momento della creazione di un processo in un sistema operativo moderno?",
        "answers": [
            "Inizializzazione del process control block",
            "Allocazione di spazio di memoria RAM e di swap",
            "Esecuzione del processo",
            "Creazione di un PID unico"
        ],
        "correct": "c",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question":"Quale delle seguenti affermazioni sul file system FAT è vera?",
        "answers": [
            "Usa il metodo di allocazione contiguo",
            "La tabella di allocazione dei file contiene tante righe quanti sono i file memorizzati sul disco, più una riga speciale per i blocchi liberi",
            "Ogni cluster del disco contiene sia dati del disco che l'indirizzo del prossimo cluster (o l'indicazione che si tratta dell'ultimo cluster)",
            "Nessuna delle altre opzioni è vera"
        ],
        "correct": "d",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question":"Quale delle seguenti affermazioni sul requisito di rilocazione nella gestione della memoria è vera?",
        "answers": [
            "Nessuna delle altre opzioni è corretta",
            "Prevede che un processo possa essere allocato in memoria principale, in fase di avvio o al rientro da uno swap, in una tra diverse posizioni possibili",
            "Prevede che chi programma un processo utente possa richiedere, tramite system call, la posizione del processo in memoria principale",
            "Per poterlo soddisfare senza creare overhead inaccettabile, è sempre stato necessario dell'hardware aggiuntivo"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    },
    {
        "question":"Quale delle seguenti affermazioni sul modello dei processi a 7 stati è vera?",
        "answers": [
            "Nessuna delle altre opzioni è vera",
            "Gli stati Ready, New e Blocked del modello a 5 stati vengono sdoppiati, e ne viene creata una versione Suspend",
            "Un processo è Suspend quando scade il timeout del dispatcher",
            "È possibile la transizione Ready/Suspend ==> Blocked/Suspend"
        ],
        "correct": "a",
        "answers_have_code": 0,
        "has_code": 0,
        "code": ""    
    } 
]
